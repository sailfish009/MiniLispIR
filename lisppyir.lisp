;; LispPyIR: Lisp + Python + LLVM IR 융합 언어
;; 수정: llvmlite의 IR 빌더, 파서, 최적화를 Lisp로 구현 (JIT 제외)
(defvar %ir-patterns nil)  ; IR 패턴 저장
(defvar %opt-rules nil)    ; 최적화 규칙 저장
(defvar %current-mode 'lisp)  ; 현재 모드: 'lisp 또는 'python
(defvar %modules nil)      ; 모듈 저장
(defvar %types nil)        ; 타입 저장
(defvar %indent-level 0)   ; 들여쓰기 레벨
(defvar %ir-module nil)    ; IR 모듈 상태
(defvar %ir-block nil)     ; 현재 블록

(defun set-mode (mode)
  (cond ((eq mode 'lisp) (set '%current-mode 'lisp) (write-output "Mode set to Lisp"))
        ((eq mode 'python) (set '%current-mode 'python) (write-output "Mode set to Python"))
        (t (error "Invalid mode: use 'lisp or 'python"))))

(defun get-mode ()
  (write-output (concat "Current mode: " %current-mode))
  %current-mode)

(defun eval-in-mode (mode expr)
  (let ((prev-mode %current-mode))
    (set-mode mode)
    (let ((result (eval expr nil)))
      (set-mode prev-mode)
      result)))

(defun eval (e a)
  (cond ((null e) (error "Null expression"))
        ((atom e) (assoc e a))
        ((eq (car e) 'quote) (car (cdr e)))
        ((eq (car e) 'atom) (if (atom (eval (car (cdr e)) a)) 't 'nil))
        ((eq (car e) 'eq) (if (eq (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)) 't 'nil))
        ((eq (car e) 'car) (let ((x (eval (car (cdr e)) a))) 
                             (if (null x) (error "Car of nil") (car x))))
        ((eq (car e) 'cdr) (let ((x (eval (car (cdr e)) a))) 
                             (if (null x) (error "Cdr of nil") (cdr x))))
        ((eq (car e) 'cons) (cons (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) 'cond) (evcon (cdr e) a))
        ((eq (car e) 'defun) (set (car (cdr e)) (cons 'lambda (cdr (cdr e)))))
        ((eq (car e) 'def-type) (set-type (car (cdr e)) (car (cdr (cdr e)))))
        ((eq (car e) 'def-class) (def-class (car (cdr e)) (car (cdr (cdr e))) (cdr (cdr (cdr e)))))
        ((eq (car e) 'own) (own (car (cdr e)) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) 'alloc) (ir-alloc (eval (car (cdr e)) a)))
        ((eq (car e) 'for-loop) (evfor (cdr e) a))
        ((eq (car e) 'while-loop) (evwhile (cdr e) a))
        ((eq (car e) 'range) (range (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) 'list-comp) (list-comp (car (cdr e)) (car (cdr (cdr e))) a))
        ((eq (car e) 'dict-comp) (dict-comp (car (cdr e)) (car (cdr (cdr e))) a))
        ((eq (car e) 'set-comp) (set-comp (car (cdr e)) (car (cdr (cdr e))) a))
        ((eq (car e) 'comptime) (comptime-eval (car (cdr e))))
        ((eq (car e) 'try) (evtry (cdr e) a))
        ((eq (car e) 'raise) (raise (eval (car (cdr e)) a)))
        ((eq (car e) '+) (add (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) '-) (sub (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) '*) (mul (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) '/) (div (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) '==) (eq (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) 'and) (and-op (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) 'or) (or-op (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) 'not) (not-op (eval (car (cdr e)) a)))
        ((eq (car e) 'lambda) (cons 'lambda (cons (car (cdr e)) (eval (car (cdr (cdr e))) a))))
        ((eq (car e) 'list) (make-list (eval-list (cdr e) a)))
        ((eq (car e) 'dict) (make-dict (eval-list (cdr e) a)))
        ((eq (car e) 'set) (make-set (eval-list (cdr e) a)))
        ((eq (car e) 'tuple) (make-tuple (eval-list (cdr e) a)))
        ((eq (car e) 'slice) (slice (eval (car (cdr e)) a) 
                                    (eval (car (cdr (cdr e))) a) 
                                    (eval (car (cdr (cdr (cdr e)))) a)))
        ((eq (car e) 'import) (import-module (car (cdr e))))
        ((eq (car e) 'async-defun) (set (car (cdr e)) (cons 'async-lambda (cdr (cdr e)))))
        ((eq (car e) 'await) (await (eval (car (cdr e)) a)))
        ((eq (car e) 'print) (print (eval (car (cdr e)) a)))
        ((eq (car e) 'gc) (gc a))
        ((eq (car e) 'read-input) (read-input))
        ((eq (car e) 'write-output) (write-output (eval (car (cdr e)) a)))
        ((eq (car e) 'syscall) (syscall (eval (car (cdr e)) a) 
                                       (eval (car (cdr (cdr e))) a)
                                       (eval (car (cdr (cdr (cdr e)))) a)
                                       (eval (car (cdr (cdr (cdr (cdr e))))) a)))
        ((eq (car e) 'ir-gen) (ir-gen (eval (car (cdr e)) a)))
        ((eq (car e) 'ir-eval) (ir-eval (eval (car (cdr e)) a)))
        ((eq (car e) 'ir-alloc) (ir-alloc (eval (car (cdr e)) a)))
        ((eq (car e) 'ir-call) (ir-call (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
        ((eq (car e) 'learn-ir) (learn-ir (car (cdr e)) (car (cdr (cdr e)))))
        ((eq (car e) 'infer-ir) (infer-ir (car (cdr e))))
        ((eq (car e) 'learn-rule) (learn-rule (car (cdr e)) (car (cdr (cdr e)))))
        ((eq (car e) 'apply-rule) (apply-rule (car (cdr e))))
        ((eq (car e) 'set-mode) (set-mode (car (cdr e))))
        ((eq (car e) 'get-mode) (get-mode))
        ((eq (car e) 'eval-in-mode) (eval-in-mode (car (cdr e)) (car (cdr (cdr e)))))
        (t (let ((fn (eval (car e) a)))
             (if (null fn) (error "Undefined function")
                 (eval (car (cdr (cdr fn)))
                       (cons (cons (car (car (cdr fn))) (eval (car (cdr e)) a)) a)))))))

(defun evcon (c a)
  (cond ((null c) nil)
        ((eval (car (car c)) a) (eval (car (cdr (car c))) a))
        (t (evcon (cdr c) a))))

(defun evfor (loop a)
  (let ((var (car loop))
        (iter (eval (car (cdr loop)) a))
        (body (car (cdr (cdr loop)))))
    (cond ((null iter) nil)
          ((eq body 'break) nil)
          ((eq body 'continue) (evfor (cons var (cons (cdr iter) (cons body nil))) a))
          (t (eval body (cons (cons var (car iter)) a))
             (evfor (cons var (cons (cdr iter) (cons body nil))) a)))))

(defun evwhile (loop a)
  (let ((cond (eval (car loop) a))
        (body (car (cdr loop))))
    (cond ((not cond) nil)
          ((eq body 'break) nil)
          ((eq body 'continue) (evwhile loop a))
          (t (eval body a) (evwhile loop a)))))

(defun evtry (try-block a)
  (let ((body (car try-block))
        (except (car (cdr try-block))))
    (if (error-occurred body a)
        (eval except a)
        (eval body a))))

(defun read-input ()
  (let ((raw (raw-input)))  ; LLVM IR @raw_input 호출
    (if (eq %current-mode 'python)
        (read-python (tokenize-python raw) %indent-level)
        (read (tokenize raw)))))

(defun tokenize-python (input)
  (cond ((null input) nil)
        ((eq (car input) #\ ) (handle-indent (cdr input)))
        ((eq (car input) #\newline) (cons 'newline (tokenize-python (cdr input))))
        ((eq (car input) #\:) (cons 'colon (tokenize-python (cdr input))))
        ((eq (car input) #\() (cons 'lparen (tokenize-python (cdr input))))
        ((eq (car input) #\)) (cons 'rparen (tokenize-python (cdr input))))
        ((eq (car input) #\[) (cons 'lbrack (tokenize-python (cdr input))))
        ((eq (car input) #\]) (cons 'rbrack (tokenize-python (cdr input))))
        ((eq (car input) #\{) (cons 'lbrace (tokenize-python (cdr input))))
        ((eq (car input) #\}) (cons 'rbrace (tokenize-python (cdr input))))
        ((eq (car input) #\,) (cons 'comma (tokenize-python (cdr input))))
        ((eq (car input) #\=) (if (eq (car (cdr input)) #\=)
                                 (cons '== (tokenize-python (cdr (cdr input))))
                                 (cons '= (tokenize-python (cdr input)))))
        ((eq (car input) #\+) (if (eq (car (cdr input)) #\=)
                                 (cons '+= (tokenize-python (cdr (cdr input))))
                                 (cons '+ (tokenize-python (cdr input)))))
        ((eq (car input) #\-) (if (eq (car (cdr input)) #\=)
                                 (cons '-= (tokenize-python (cdr (cdr input))))
                                 (cons '- (tokenize-python (cdr input)))))
        ((eq (car input) #\*) (if (eq (car (cdr input)) #\=)
                                 (cons '*= (tokenize-python (cdr (cdr input))))
                                 (cons '* (tokenize-python (cdr input)))))
        ((eq (car input) #\/) (if (eq (car (cdr input)) #\=)
                                 (cons '/= (tokenize-python (cdr (cdr input))))
                                 (cons '/ (tokenize-python (cdr input)))))
        ((eq (car input) #\<) (if (eq (car (cdr input)) #\=)
                                 (cons '<= (tokenize-python (cdr (cdr input))))
                                 (cons '< (tokenize-python (cdr input)))))
        ((eq (car input) #\>) (if (eq (car (cdr input)) #\=)
                                 (cons '>= (tokenize-python (cdr (cdr input))))
                                 (cons '> (tokenize-python (cdr input)))))
        ((eq (car input) #\!) (if (eq (car (cdr input)) #\=)
                                 (cons '!= (tokenize-python (cdr (cdr input))))
                                 (error "Invalid operator")))
        (t (let ((sym (collect-symbol input)))
             (cons (string-to-symbol sym) (tokenize-python (skip-symbol input)))))))

(defun handle-indent (input)
  (let ((spaces (count-spaces input)))
    (if (> spaces %indent-level)
        (progn (set '%indent-level spaces) (cons 'indent (tokenize-python input)))
        (if (< spaces %indent-level)
            (progn (set '%indent-level spaces) (cons 'dedent (tokenize-python input)))
            (tokenize-python input)))))

(defun count-spaces (input)
  (if (or (null input) (not (eq (car input) #\ )))
      0
      (+ 1 (count-spaces (cdr input)))))

(defun read-python (tokens indent)
  (cond ((null tokens) nil)
        ((eq (car tokens) 'def) (read-python-def (cdr tokens) indent))
        ((eq (car tokens) 'class) (read-python-class (cdr tokens) indent))
        ((eq (car tokens) 'if) (read-python-if (cdr tokens) indent))
        ((eq (car tokens) 'for) (read-python-for (cdr tokens) indent))
        ((eq (car tokens) 'while) (read-python-while (cdr tokens) indent))
        ((eq (car tokens) 'try) (read-python-try (cdr tokens) indent))
        ((eq (car tokens) 'import) (read-python-import (cdr tokens)))
        ((eq (car tokens) 'lambda) (read-python-lambda (cdr tokens)))
        ((eq (car tokens) 'lbrack) (read-python-list (cdr tokens)))
        ((eq (car tokens) 'lbrace) (read-python-dict-or-set (cdr tokens)))
        ((eq (car tokens) 'async) (read-python-async (cdr tokens) indent))
        ((eq (car tokens) 'indent) (read-python (cdr tokens) (+ indent 1)))
        ((eq (car tokens) 'dedent) (read-python (cdr tokens) (- indent 1)))
        (t (read-python-expr tokens))))

(defun read-python-def (tokens indent)
  (let ((name (car tokens))
        (params (collect-until 'colon (cdr tokens)))
        (body (collect-until-indent indent (skip-colon (cdr tokens)))))
    (cons 'defun (cons name (cons params (cons (read-python body indent) nil))))))

(defun read-python-class (tokens indent)
  (let ((name (car tokens))
        (bases (collect-until 'colon (cdr tokens)))
        (body (collect-until-indent indent (skip-colon (cdr tokens)))))
    (cons 'def-class (cons name (cons bases (read-python body indent))))))

(defun read-python-if (tokens indent)
  (let ((cond (collect-until 'colon tokens))
        (then (collect-until 'elif (skip-colon tokens)))
        (elif (collect-until 'else (skip-elif (skip-colon tokens))))
        (else (collect-until-indent indent (skip-else (skip-colon tokens)))))
    (cons 'cond (append (list (cons (read-python-expr cond) (cons (read-python then indent) nil))
                              (if elif (cons (read-python-expr elif) (cons (read-python (skip-colon (cdr elif)) indent) nil)) nil))
                        (if else (list (cons 't (cons (read-python else indent) nil))) nil)))))

(defun read-python-for (tokens indent)
  (let ((var (car tokens))
        (iter (collect-until 'colon (skip-in (cdr tokens))))
        (body (collect-until-indent indent (skip-colon (cdr tokens)))))
    (cons 'for-loop (cons var (cons (read-python-expr iter) (cons (read-python body indent) nil))))))

(defun read-python-while (tokens indent)
  (let ((cond (collect-until 'colon tokens))
        (body (collect-until-indent indent (skip-colon tokens))))
    (cons 'while-loop (cons (read-python-expr cond) (cons (read-python body indent) nil)))))

(defun read-python-try (tokens indent)
  (let ((body (collect-until 'except (skip-colon tokens)))
        (except (collect-until-indent indent (skip-except (skip-colon tokens)))))
    (cons 'try (cons (read-python body indent) (cons (read-python except indent) nil)))))

(defun read-python-import (tokens)
  (cons 'import (cons (car tokens) nil)))

(defun read-python-lambda (tokens)
  (let ((params (collect-until 'colon tokens))
        (body (collect-until 'newline (skip-colon tokens))))
    (cons 'lambda (cons params (cons (read-python-expr body) nil)))))

(defun read-python-list (tokens)
  (let ((items (collect-until 'rbrack tokens)))
    (if (is-comp items)
        (read-python-comp items)
        (cons 'list (read-python-expr items)))))

(defun read-python-dict-or-set (tokens)
  (let ((items (collect-until 'rbrace tokens)))
    (if (has-colon items)
        (cons 'dict (read-python-dict-items items))
        (if (is-comp items)
            (read-python-comp items)
            (cons 'set (read-python-expr items))))))

(defun read-python-async (tokens indent)
  (if (eq (car tokens) 'def)
      (let ((name (car (cdr tokens)))
            (params (collect-until 'colon (cdr (cdr tokens))))
            (body (collect-until-indent indent (skip-colon (cdr (cdr tokens))))))
        (cons 'async-defun (cons name (cons params (cons (read-python body indent) nil)))))
      (error "Invalid async syntax")))

(defun read-python-comp (tokens)
  (let ((expr (car tokens))
        (comp (cdr tokens)))
    (if (eq (car comp) 'for)
        (cons (if (is-dict-comp tokens) 'dict-comp 'list-comp)
              (cons (read-python-expr expr) (read-python-for-comp comp)))
        (error "Invalid comprehension"))))

(defun read-python-for-comp (tokens)
  (let ((var (car (cdr tokens)))
        (iter (collect-until 'colon (skip-in (cdr (cdr tokens)))))
        (body (collect-until 'newline (skip-colon (cdr (cdr tokens))))))
    (cons var (cons (read-python-expr iter) (if body (read-python body 0) nil)))))

(defun read-python-dict-items (tokens)
  (let ((pairs (split-by 'colon tokens)))
    (mapcar (lambda (p) (cons (read-python-expr (car p)) (read-python-expr (car (cdr p))))) pairs)))

(defun read-python-expr (tokens)
  (cond ((null tokens) nil)
        ((member (car tokens) '(+ - * / == != < > <= >= and or not))
         (parse-infix tokens))
        ((eq (car tokens) 'range) 
         (let ((args (collect-until 'rparen (cdr tokens))))
           (cons 'range (read-python-expr args))))
        ((eq (car tokens) 'lbrack) (read-python-list (cdr tokens)))
        ((eq (car tokens) 'lbrace) (read-python-dict-or-set (cdr tokens)))
        ((eq (car tokens) 'lparen) (cons 'tuple (read-python-expr (collect-until 'rparen (cdr tokens)))))
        (t (car tokens))))

(defun parse-infix (tokens)
  (let ((op (car tokens))
        (arg1 (car (cdr tokens)))
        (arg2 (car (cdr (cdr tokens)))))
    (cons op (cons arg1 (cons arg2 nil)))))

(defun collect-until-indent (indent tokens)
  (if (or (null tokens) (and (eq (car tokens) 'dedent) (<= %indent-level indent)))
      nil
      (cons (car tokens) (collect-until-indent indent (cdr tokens)))))

(defun collect-until (delimiter tokens)
  (if (or (null tokens) (eq (car tokens) delimiter))
      nil
      (cons (car tokens) (collect-until delimiter (cdr tokens)))))

(defun skip-colon (tokens) (if (eq (car tokens) 'colon) (cdr tokens) tokens))
(defun skip-in (tokens) (if (eq (car tokens) 'in) (cdr tokens) tokens))
(defun skip-else (tokens) (if (eq (car tokens) 'else) (cdr tokens) tokens))
(defun skip-elif (tokens) (if (eq (car tokens) 'elif) (cdr tokens) tokens))
(defun skip-except (tokens) (if (eq (car tokens) 'except) (cdr tokens) tokens))

(defun is-comp (tokens) (member 'for tokens))
(defun has-colon (tokens) (member 'colon tokens))
(defun is-dict-comp (tokens) (member 'colon tokens))

(defun split-by (delimiter tokens)
  (let ((result nil) (current nil))
    (dolist (t tokens)
      (if (eq t delimiter)
          (progn (push current result) (set 'current nil))
          (push t current)))
    (push current result)
    (reverse result)))

(defun read (input)
  (cond ((null input) nil)
        ((eq (car input) 'lparen) (read-list (cdr input)))
        ((eq (car input) 'def) (read-def (cdr input)))
        ((eq (car input) 'if) (read-if (cdr input)))
        ((eq (car input) 'for) (read-for (cdr input)))
        ((eq (car input) 'comptime) (read-comptime (cdr input)))
        (t (car input))))

(defun read-list (input)
  (cond ((eq (car input) 'rparen) nil)
        (t (cons (read input) (read-list (cdr input))))))

(defun read-def (input)
  (let ((name (car input))
        (params (car (cdr input)))
        (body (car (cdr (cdr input)))))
    (cons 'defun (cons name (cons params (cons body nil))))))

(defun read-if (input)
  (let ((cond (car input))
        (then (car (cdr input)))
        (else (car (cdr (cdr input)))))
    (cons 'cond (cons (cons cond (cons then nil))
                      (cons (cons 't (cons else nil)) nil)))))

(defun read-for (input)
  (let ((var (car input))
        (iter (car (cdr input)))
        (body (car (cdr (cdr input)))))
    (cons 'for-loop (cons var (cons iter (cons body nil))))))

(defun read-comptime (input)
  (cons 'comptime (cons (car input) nil)))

(defun write-output (x)
  (ir-call "write" (list 1 x (length x)))  ; IR @write 호출
  x)

(defun tokenize (input)
  (cond ((null input) nil)
        ((eq (car input) #\() (cons 'lparen (tokenize (cdr input))))
        ((eq (car input) #\)) (cons 'rparen (tokenize (cdr input))))
        ((eq (car input) #\ ) (tokenize (cdr input)))
        ((eq (car input) #\newline) (tokenize (cdr input)))
        (t (let ((sym (collect-symbol input)))
             (cons (string-to-symbol sym) (tokenize (skip-symbol input)))))))

(defun collect-symbol (input)
  (if (or (null input)
          (eq (car input) #\()
          (eq (car input) #\))
          (eq (car input) #\ )
          (eq (car input) #\newline)
          (eq (car input) #\+)
          (eq (car input) #\-)
          (eq (car input) #\*)
          (eq (car input) #\/)
          (eq (car input) #\=)
          (eq (car input) #\<)
          (eq (car input) #\>)
          (eq (car input) #\[)
          (eq (car input) #\])
          (eq (car input) #\{)
          (eq (car input) #\})
          (eq (car input) #\,))
      nil
      (cons (car input) (collect-symbol (cdr input)))))

(defun skip-symbol (input)
  (if (or (null input)
          (eq (car input) #\()
          (eq (car input) #\))
          (eq (car input) #\ )
          (eq (car input) #\newline)
          (eq (car input) #\+)
          (eq (car input) #\-)
          (eq (car input) #\*)
          (eq (car input) #\/)
          (eq (car input) #\=)
          (eq (car input) #\<)
          (eq (car input) #\>)
          (eq (car input) #\[)
          (eq (car input) #\])
          (eq (car input) #\{)
          (eq (car input) #\})
          (eq (car input) #\,))
      input
      (skip-symbol (cdr input))))

(defun string-to-symbol (chars)
  (cond ((null chars) nil)
        ((eq (car chars) #\0) '0)
        ((eq (car chars) #\1) '1)
        ((eq (car chars) #\2) '2)
        (t (intern (chars-to-string chars)))))

(defun chars-to-string (chars)
  (if (null chars) nil
      (cons (car chars) (chars-to-string (cdr chars)))))

(defun length (lst)
  (if (null lst) 0
      (+ 1 (length (cdr lst)))))

(defun add (a b)
  (cond ((numberp a) (cond ((numberp b) (ir-gen (list '+ a b))) (t (error "Non-numeric operand"))))
        (t (error "Non-numeric operand"))))

(defun sub (a b)
  (cond ((numberp a) (cond ((numberp b) (ir-gen (list '- a b))) (t (error "Non-numeric operand"))))
        (t (error "Non-numeric operand"))))

(defun mul (a b)
  (cond ((numberp a) (cond ((numberp b) (ir-gen (list '* a b))) (t (error "Non-numeric operand"))))
        (t (error "Non-numeric operand"))))

(defun div (a b)
  (cond ((numberp a) (cond ((numberp b) (ir-gen (list '/ a b))) (t (error "Non-numeric operand"))))
        (t (error "Non-numeric operand"))))

(defun eq (a b)
  (ir-gen (list '== a b)))

(defun and-op (a b)
  (ir-gen (list 'and a b)))

(defun or-op (a b)
  (ir-gen (list 'or a b)))

(defun not-op (a)
  (ir-gen (list 'not a)))

(defun print (x)
  (write-output x)
  x)

(defun numberp (x)
  (cond ((eq x '0) 't)
        ((eq x '1) 't)
        ((eq x '2) 't)
        (t 'nil)))

(defun py-def (name params body)
  (set name (cons 'lambda (cons params (cons body nil)))))

(defun py-if (cond then else)
  (cond (cond then) (t else)))

(defun py-for (var iter body)
  (for-loop var iter body))

(defun range (start end)
  (if (>= start end) nil
      (cons start (range (+ start 1) end))))

(defun list-comp (expr var-iter a)
  (let ((var (car var-iter))
        (iter (eval (car (cdr var-iter)) a)))
    (mapcar (lambda (x) (eval expr (cons (cons var x) a))) iter)))

(defun dict-comp (pair var-iter a)
  (let ((key (car pair))
        (value (car (cdr pair)))
        (var (car var-iter))
        (iter (eval (car (cdr var-iter)) a)))
    (mapcar (lambda (x) (cons (eval key (cons (cons var x) a))
                             (eval value (cons (cons var x) a)))) iter)))

(defun set-comp (expr var-iter a)
  (let ((var (car var-iter))
        (iter (eval (car (cdr var-iter)) a)))
    (make-set (mapcar (lambda (x) (eval expr (cons (cons var x) a))) iter)))

(defun mapcar (fn lst)
  (if (null lst) nil
      (cons (fn (car lst)) (mapcar fn (cdr lst)))))

(defun make-list (items)
  (cons 'list items))

(defun make-dict (pairs)
  (cons 'dict pairs))

(defun make-set (items)
  (cons 'set items))

(defun make-tuple (items)
  (cons 'tuple items))

(defun slice (obj start end)
  (ir-call "slice" (list obj start end)))

(defun import-module (name)
  (set '%modules (cons (cons name (load-module name)) %modules))
  name)

(defun load-module (name)
  (cond ((eq name 'math) (list (cons 'sin 'math.sin) (cons 'cos 'math.cos)))
        ((eq name 'sys) (list (cons 'exit 'sys.exit)))
        (t (error "Module not found"))))

(defun def-class (name bases body)
  (set name (cons 'class (cons bases body)))
  name)

(defun comptime-eval (expr)
  (cond ((numberp expr) expr)
        ((eq (car expr) 'type) (set-type (car (cdr expr)) (car (cdr (cdr expr)))))
        ((eq (car expr) 'alloc) (ir-alloc (eval (car (cdr expr)) nil)))
        ((eq (car expr) 'assert-type) 
         (if (eq (car (cdr expr)) (car (cdr (cdr expr)))) 
             (car (cdr expr)) 
             (error "Type mismatch")))
        ((eq (car expr) 'if) 
         (let ((cond (eval (car (cdr expr)) nil))
               (then (car (cdr (cdr expr))))
               (else (car (cdr (cdr (cdr expr))))))
           (optimize-ir (ir-gen (if cond then else)))))
        ((eq (car expr) 'for-loop) 
         (let ((var (car (cdr expr)))
               (iter (eval (car (cdr (cdr expr))) nil))
               (body (car (cdr (cdr (cdr expr))))))
           (optimize-ir (ir-gen (list 'for-loop var iter body)))))
        (t (apply-rule expr))))

(defun ir-alloc (type)
  (raw-ir-alloc type))  ; LLVM IR @raw_ir_alloc

(defun ir-call (fn args)
  (raw-ir-call fn args))  ; LLVM IR @raw_ir_call

;; llvmlite IR 빌더 구현
(defun ir-builder (module)
  (set '%ir-module (cons 'module (cons module nil)))
  (set '%ir-block (cons 'block (cons (gensym) nil)))
  %ir-module)

(defun ir-add (type a b)
  (let ((instr (list 'add type a b)))
    (set '%ir-block (append %ir-block (list instr)))
    instr))

(defun ir-sub (type a b)
  (let ((instr (list 'sub type a b)))
    (set '%ir-block (append %ir-block (list instr)))
    instr))

(defun ir-mul (type a b)
  (let ((instr (list 'mul type a b)))
    (set '%ir-block (append %ir-block (list instr)))
    instr))

(defun ir-div (type a b)
  (let ((instr (list 'div type a b)))
    (set '%ir-block (append %ir-block (list instr)))
    instr))

(defun ir-cmp (pred a b)
  (let ((instr (list 'cmp pred a b)))
    (set '%ir-block (append %ir-block (list instr)))
    instr))

(defun ir-loop (var iter body)
  (let ((instr (list 'loop var iter body)))
    (set '%ir-block (append %ir-block (list instr)))
    instr))

;; llvmlite IR 파서 구현
(defun tokenize-ir (ir-str)
  (cond ((null ir-str) nil)
        ((eq (car ir-str) #\ ) (tokenize-ir (cdr ir-str)))
        ((eq (car ir-str) #\,) (cons 'comma (tokenize-ir (cdr ir-str))))
        ((eq (car ir-str) #\=) (cons 'assign (tokenize-ir (cdr ir-str))))
        ((eq (car ir-str) #\%) (cons 'reg (collect-reg (cdr ir-str))))
        (t (let ((sym (collect-symbol ir-str)))
             (cons (string-to-symbol sym) (tokenize-ir (skip-symbol ir-str)))))))

(defun collect-reg (input)
  (if (or (null input) (eq (car input) #\ ) (eq (car input) #\,))
      nil
      (cons (car input) (collect-reg (cdr input)))))

(defun parse-ir (ir-str)
  (let ((tokens (tokenize-ir ir-str)))
    (cond ((eq (car tokens) 'add) (list 'add (car (cdr tokens)) (car (cdr (cdr tokens))) (car (cdr (cdr (cdr tokens))))))
          ((eq (car tokens) 'sub) (list 'sub (car (cdr tokens)) (car (cdr (cdr tokens))) (car (cdr (cdr (cdr tokens))))))
          ((eq (car tokens) 'mul) (list 'mul (car (cdr tokens)) (car (cdr (cdr tokens))) (car (cdr (cdr (cdr tokens))))))
          ((eq (car tokens) 'div) (list 'div (car (cdr tokens)) (car (cdr (cdr tokens))) (car (cdr (cdr (cdr tokens))))))
          ((eq (car tokens) 'cmp) (list 'cmp (car (cdr tokens)) (car (cdr (cdr tokens))) (car (cdr (cdr (cdr tokens))))))
          ((eq (car tokens) 'loop) (list 'loop (car (cdr tokens)) (car (cdr (cdr tokens))) (car (cdr (cdr (cdr tokens))))))
          (t (error "Invalid IR string")))))

;; llvmlite 최적화 구현
(defun optimize-ir (ir)
  (cond ((and (eq (car ir) 'add) (numberp (car (cdr (cdr ir))) (numberp (car (cdr (cdr (cdr ir)))))))
         (+ (car (cdr (cdr ir))) (car (cdr (cdr (cdr ir))))))  ; 상수 접기
        ((and (eq (car ir) 'sub) (numberp (car (cdr (cdr ir))) (numberp (car (cdr (cdr (cdr ir)))))))
         (- (car (cdr (cdr ir))) (car (cdr (cdr (cdr ir))))))
        ((and (eq (car ir) 'mul) (numberp (car (cdr (cdr ir))) (numberp (car (cdr (cdr (cdr ir)))))))
         (* (car (cdr (cdr ir))) (car (cdr (cdr (cdr ir))))))
        ((and (eq (car ir) 'div) (numberp (car (cdr (cdr ir))) (numberp (car (cdr (cdr (cdr ir)))))))
         (/ (car (cdr (cdr ir))) (car (cdr (cdr (cdr ir))))))
        ((and (eq (car ir) 'if) (eq (car (cdr ir)) '1)) (car (cdr (cdr ir))))  ; if 1 x y → x
        (t ir)))

(defun ir-gen (expr)
  (let ((inferred (infer-ir expr)))
    (cond (inferred inferred)
          ((numberp expr) expr)
          ((eq (car expr) '+) 
           (let ((a (eval (car (cdr expr)) nil))
                 (b (eval (car (cdr (cdr expr))) nil))
                 (ir (ir-add 'i32 a b)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) '-) 
           (let ((a (eval (car (cdr expr)) nil))
                 (b (eval (car (cdr (cdr expr))) nil))
                 (ir (ir-sub 'i32 a b)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) '*) 
           (let ((a (eval (car (cdr expr)) nil))
                 (b (eval (car (cdr (cdr expr))) nil))
                 (ir (ir-mul 'i32 a b)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) '/) 
           (let ((a (eval (car (cdr expr)) nil))
                 (b (eval (car (cdr (cdr expr))) nil))
                 (ir (ir-div 'i32 a b)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) '==) 
           (let ((a (eval (car (cdr expr)) nil))
                 (b (eval (car (cdr (cdr expr))) nil))
                 (ir (ir-cmp 'eq a b)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'and) 
           (let ((a (eval (car (cdr expr)) nil))
                 (b (eval (car (cdr (cdr expr))) nil))
                 (ir (ir-cmp 'and a b)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'or) 
           (let ((a (eval (car (cdr expr)) nil))
                 (b (eval (car (cdr (cdr expr))) nil))
                 (ir (ir-cmp 'or a b)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'not) 
           (let ((a (eval (car (cdr expr)) nil))
                 (ir (ir-cmp 'not a)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'if) 
           (let ((cond (eval (car (cdr expr)) nil))
                 (then (car (cdr (cdr expr))))
                 (else (car (cdr (cdr (cdr expr)))))
                 (ir (raw-ir-gen (list 'if 'i1 cond then else))))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'for-loop) 
           (let ((var (car (cdr expr)))
                 (iter (eval (car (cdr (cdr expr))) nil))
                 (body (car (cdr (cdr (cdr expr)))))
                 (ir (ir-loop var iter body)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'while-loop) 
           (let ((cond (eval (car (cdr expr)) nil))
                 (body (car (cdr (cdr expr))))
                 (ir (raw-ir-gen (list 'while cond body))))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'call) 
           (let ((fn (car (cdr expr)))
                 (args (cdr (cdr expr)))
                 (ir (raw-ir-gen (cons 'call (cons fn args)))))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'list-comp) 
           (let ((expr (car (cdr expr)))
                 (var-iter (car (cdr (cdr expr))))
                 (var (car var-iter))
                 (iter (eval (car (cdr var-iter)) nil))
                 (ir (ir-loop var iter expr)))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'dict-comp) 
           (let ((pair (car (cdr expr)))
                 (var-iter (car (cdr (cdr expr))))
                 (var (car var-iter))
                 (iter (eval (car (cdr var-iter)) nil))
                 (ir (raw-ir-gen (list 'dict-loop var iter pair))))
             (learn-ir expr ir)
             (optimize-ir ir)))
          ((eq (car expr) 'set-comp) 
           (let ((expr (car (cdr expr)))
                 (var-iter (car (cdr (cdr expr))))
                 (var (car var-iter))
                 (iter (eval (car (cdr var-iter)) nil))
                 (ir (raw-ir-gen (list 'set-loop var iter expr))))
             (learn-ir expr ir)
             (optimize-ir ir)))
          (t (error "Unsupported IR expression")))))

(defun ir-eval (ir)
  (let ((parsed (parse-ir (ir-to-string ir))))
    (raw-ir-eval parsed)))  ; LLVM IR @raw_ir_eval로 실행

(defun ir-to-string (ir)
  (cond ((atom ir) ir)
        ((eq (car ir) 'add) (concat "add " (car (cdr ir)) " " (car (cdr (cdr ir))) ", " (car (cdr (cdr (cdr ir))))))
        ((eq (car ir) 'sub) (concat "sub " (car (cdr ir)) " " (car (cdr (cdr ir))) ", " (car (cdr (cdr (cdr ir))))))
        ((eq (car ir) 'mul) (concat "mul " (car (cdr ir)) " " (car (cdr (cdr ir))) ", " (car (cdr (cdr (cdr ir))))))
        ((eq (car ir) 'div) (concat "div " (car (cdr ir)) " " (car (cdr (cdr ir))) ", " (car (cdr (cdr (cdr ir))))))
        ((eq (car ir) 'cmp) (concat "cmp " (car (cdr ir)) " " (car (cdr (cdr ir))) ", " (car (cdr (cdr (cdr ir))))))
        ((eq (car ir) 'loop) (concat "loop " (car (cdr ir)) " " (ir-to-string (car (cdr (cdr ir)))) " " (ir-to-string (car (cdr (cdr (cdr ir)))))))
        (t (error "Invalid IR for string conversion"))))

(defun learn-ir (expr ir)
  (set '%ir-patterns (cons (cons expr ir) %ir-patterns))
  (write-output "Learned IR pattern")
  ir)

(defun infer-ir (expr)
  (let ((pattern (assoc expr %ir-patterns)))
    (if pattern (cdr pattern) nil)))

(defun learn-rule (pattern replacement)
  (set '%opt-rules (cons (cons pattern replacement) %opt-rules))
  (write-output "Learned optimization rule")
  replacement)

(defun apply-rule (expr)
  (cond ((null %opt-rules) expr)
        ((match-rule (car %opt-rules) expr) 
         (apply-rule (cdr (car %opt-rules))))
        (t (apply-rule expr))))

(defun match-rule (rule expr)
  (cond ((null rule) (eq expr nil))
        ((atom rule) (eq rule expr))
        ((atom expr) nil)
        (t (and (match-rule (car rule) (car expr))
                (match-rule (cdr rule) (cdr expr))))))

(defun own (var expr)
  (let ((val (eval expr nil)))
    (set var (cons 'owned val))
    val))

(defun set-type (name spec)
  (set '%types (cons (cons name spec) %types))
  name)

(defun gc (env)
  (let ((marked (gc-mark env nil))
        (swept (gc-sweep marked)))
    (write-output "GC completed")
    swept))

(defun gc-mark (obj marked)
  (cond ((null obj) marked)
        ((atom obj) (cons obj marked))
        (t (let ((new-marked (gc-mark (car obj) marked)))
             (gc-mark (cdr obj) new-marked)))))

(defun gc-sweep (marked)
  (write-output "Sweeping unused objects")
  marked)  ; LLVM IR @deinit 위임

(defun syscall (num fd buf len)
  (ir-call "syscall" (list num fd buf len)))  ; IR @syscall 호출

(defun concat (str1 str2)
  (chars-to-string (append (string-to-chars str1) (string-to-chars str2))))

(defun string-to-chars (str)
  (if (null str) nil
      (cons (car str) (string-to-chars (cdr str)))))

(defun append (lst1 lst2)
  (if (null lst1) lst2
      (cons (car lst1) (append (cdr lst1) lst2))))

(defun error-occurred (body a)
  (ir-call "check_error" (list body)))  ; LLVM IR @check_error

(defun raise (exc)
  (ir-call "raise" (list exc)))  ; LLVM IR @raise

(defun await (coroutine)
  (ir-call "await" (list coroutine)))  ; LLVM IR @await

(defun bootstrap ()
  (eval (quote
         (defun eval (e a)
           (cond ((null e) (error "Null expression"))
                 ((atom e) (assoc e a))
                 ((eq (car e) 'quote) (car (cdr e)))
                 ((eq (car e) 'atom) (if (atom (eval (car (cdr e)) a)) 't 'nil))
                 ((eq (car e) 'eq) (if (eq (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)) 't 'nil))
                 ((eq (car e) 'car) (let ((x (eval (car (cdr e)) a))) 
                                      (if (null x) (error "Car of nil") (car x))))
                 ((eq (car e) 'cdr) (let ((x (eval (car (cdr e)) a))) 
                                      (if (null x) (error "Cdr of nil") (cdr x))))
                 ((eq (car e) 'cons) (cons (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) 'cond) (evcon (cdr e) a))
                 ((eq (car e) 'defun) (set (car (cdr e)) (cons 'lambda (cdr (cdr e)))))
                 ((eq (car e) 'def-type) (set-type (car (cdr e)) (car (cdr (cdr e)))))
                 ((eq (car e) 'def-class) (def-class (car (cdr e)) (car (cdr (cdr e))) (cdr (cdr (cdr e)))))
                 ((eq (car e) 'own) (own (car (cdr e)) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) 'alloc) (ir-alloc (eval (car (cdr e)) a)))
                 ((eq (car e) 'for-loop) (evfor (cdr e) a))
                 ((eq (car e) 'while-loop) (evwhile (cdr e) a))
                 ((eq (car e) 'range) (range (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) 'list-comp) (list-comp (car (cdr e)) (car (cdr (cdr e))) a))
                 ((eq (car e) 'dict-comp) (dict-comp (car (cdr e)) (car (cdr (cdr e))) a))
                 ((eq (car e) 'set-comp) (set-comp (car (cdr e)) (car (cdr (cdr e))) a))
                 ((eq (car e) 'comptime) (comptime-eval (car (cdr e))))
                 ((eq (car e) 'try) (evtry (cdr e) a))
                 ((eq (car e) 'raise) (raise (eval (car (cdr e)) a)))
                 ((eq (car e) '+) (add (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) '-) (sub (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) '*) (mul (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) '/) (div (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) '==) (eq (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) 'and) (and-op (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) 'or) (or-op (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) 'not) (not-op (eval (car (cdr e)) a)))
                 ((eq (car e) 'lambda) (cons 'lambda (cons (car (cdr e)) (eval (car (cdr (cdr e))) a))))
                 ((eq (car e) 'list) (make-list (eval-list (cdr e) a)))
                 ((eq (car e) 'dict) (make-dict (eval-list (cdr e) a)))
                 ((eq (car e) 'set) (make-set (eval-list (cdr e) a)))
                 ((eq (car e) 'tuple) (make-tuple (eval-list (cdr e) a)))
                 ((eq (car e) 'slice) (slice (eval (car (cdr e)) a) 
                                            (eval (car (cdr (cdr e))) a) 
                                            (eval (car (cdr (cdr (cdr e)))) a)))
                 ((eq (car e) 'import) (import-module (car (cdr e))))
                 ((eq (car e) 'async-defun) (set (car (cdr e)) (cons 'async-lambda (cdr (cdr e)))))
                 ((eq (car e) 'await) (await (eval (car (cdr e)) a)))
                 ((eq (car e) 'print) (print (eval (car (cdr e)) a)))
                 ((eq (car e) 'gc) (gc a))
                 ((eq (car e) 'read-input) (read-input))
                 ((eq (car e) 'write-output) (write-output (eval (car (cdr e)) a)))
                 ((eq (car e) 'syscall) (syscall (eval (car (cdr e)) a) 
                                                (eval (car (cdr (cdr e))) a)
                                                (eval (car (cdr (cdr (cdr e)))) a)
                                                (eval (car (cdr (cdr (cdr (cdr e))))) a)))
                 ((eq (car e) 'ir-gen) (ir-gen (eval (car (cdr e)) a)))
                 ((eq (car e) 'ir-eval) (ir-eval (eval (car (cdr e)) a)))
                 ((eq (car e) 'ir-alloc) (ir-alloc (eval (car (cdr e)) a)))
                 ((eq (car e) 'ir-call) (ir-call (eval (car (cdr e)) a) (eval (car (cdr (cdr e))) a)))
                 ((eq (car e) 'learn-ir) (learn-ir (car (cdr e)) (car (cdr (cdr e)))))
                 ((eq (car e) 'infer-ir) (infer-ir (car (cdr e))))
                 ((eq (car e) 'learn-rule) (learn-rule (car (cdr e)) (car (cdr (cdr e)))))
                 ((eq (car e) 'apply-rule) (apply-rule (car (cdr e))))
                 ((eq (car e) 'set-mode) (set-mode (car (cdr e))))
                 ((eq (car e) 'get-mode) (get-mode))
                 ((eq (car e) 'eval-in-mode) (eval-in-mode (car (cdr e)) (car (cdr (cdr e)))))
                 (t (let ((fn (eval (car e) a)))
                      (if (null fn) (error "Undefined function")
                          (eval (car (cdr (cdr fn)))
                                (cons (cons (car (car (cdr fn))) (eval (car (cdr e)) a)) a))))))))
        nil))

;; 테스트 예시
(set-mode 'python)
(eval-in-mode 'python '(for x in range(1 4) : x + 1))  ; → [2, 3, 4]
(eval-in-mode 'python '(def add(x y) : x + y))          ; → (defun add (x y) (+ x y))
(eval-in-mode 'python '[x * 2 for x in range(1 4)])     ; → [2, 4, 6]
(eval-in-mode 'python '(ir-gen '(+ 1 2)))               ; → (add i32 1 2)
(eval-in-mode 'python '(ir-eval "add i32 1, 2"))        ; → 3
(learn-ir '(+ 1 2) '(add i32 1 2))                     ; → "Learned IR pattern"
(learn-rule '(if 1 x y) 'x)                            ; → "Learned optimization rule"
(comptime '(type Int i32))
(bootstrap)